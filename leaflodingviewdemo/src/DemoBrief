这是叶子旋转加载的Demo

一、制作步骤：
1、绘制背景边框，并显示在屏幕中央
2、绘制进图条的半圆
(遇到的问题：边框的边缘线条大小无法确定，只能固定全屏时候的大小，半圆的半径也无法确定)
3、绘制整个矩形，并进行测试是否正确
4、首先定义叶子的属性，创建叶子的javaBean
5、创建叶子工厂。
6、设置叶子的可调节选项（比如说：叶子飘动的时间，旋转的时间）设置默认值和接口。
7、设置叶子x,y的位置。（x由消耗的时间来确定，y由公式y = A * sin(w * x + α) + h来确定）
8、设置叶子的旋转角度（也是根据时间和旋转方向来判断）
9、通过Matrix设置旋转然后绘制叶子的图形
10、添加风扇(步骤同：7、8、9)
11、添加进度条的百分比显示
12、当达到100%的时候停止绘制

二、制作遇到的问题：
1、基本类型的类型转换和在运算的时候的转换的问题
比如说：long time  和 long tolTime
float fraction = time/tolTime; //返回的值是0而不是百分比

回答：
JAVA的基础类型转换规则：

基本的数据类型由低级到高级分别为：（byte、short、char）——int——long——float——double 

转换规则：
（1）布尔型和其它基本数据类型之间不能相互转换；
（2）byte型可以转换为short、int、、long、float和double；
（3）short可转换为int、long、float和double；
（4）char可转换为int、long、float和double；
（5）int可转换为long、float和double；
（6）long可转换为float和double；
（7）float可转换为double；
依据的原理：
1）低级到高级的自动类型转换； （重点）
2）高级到低级的强制类型转换（会导致溢出或丢失精度）（重点）

运算时基本转换规则：
（1）如操作数之一为double，则另一个操作数先被转化为double，再参与算术运算。
（2）如两操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算。
（3）如两操作数均不为double或float，当操作数之一为long，、则另一操作数先被转换为long，再参与算术运算。
（4）如两操作数均不为double、float或long，则两操作数先被转换为int，再参与运算。
（5）如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。
依据的原理：
(1)、运算的时候会把基本类型转换成运算中最大的类型。（重点）

所以根据上述原理：
long time ;  long totalTime;
float fraction = time/total;
(1)、混合运算时，转换为该运算的最大类型，所以就是long。
(2)、计算完成后，因为long类型小于float。属于向上转型（Java自动转型）
(3)、由于long类型属于(整型类)，所以小数点后的数字都丢失了。所以最后float收到的值是0

解决方式：
将time转换为float，然后根据混合运算的机制，运算时的基本类型就是float，就不会发生小数点丢失的问题。



2、Random函数的 nextXxx(3)获得的数字范围是[0,2]还是[1,3]

回答：范围是[0,2]

3、Matrix的使用，及其原理。（在LeafView中，我将画布的中心转换了，那么Matrix是否会叠加的问题）

回答：
当canvas已经进行了移动canvas.translate(50,50);
那么之后如果使用
Matrix matrix = new Matrix();
matrix.postTranslate(50,50); //真实移动时是叠加的，也就是100,100
然后在使用rotate();进行旋转
matrix.postRotate(30) //该旋转的中心默认的并不是matrix的位移100,100，而是canvas的位置50,50
//最后作用于Bitmap
canvas.drawBitmap(bitmap,matrix,paint);//最后体现matrix.postTranslate()的作用是：bitmap设定bitmap的左上角坐标。

三、自己做的时候，与其不同的想法：
1、融合叶子和进度条的问题
我的想法是当进度条与叶子碰撞的时候，融合，并且之后删除叶子，当设置的时候再添加
作者的方法是，进度条与叶子不相关，看上去像融合就可以了。 并且复用容器中的叶子对象。

2、刷新View的问题
我使用Handle刷新。
作者直接在draw()方法中调用postInvalidate()方法。

四、增加的功能（跟作者的代码相比）
1、将风扇放到了LeafLoadingView中而不是提取出来，放到Layout中，使用动画展现
2、添加了进度条的百分比
3、修改了绘制条件（当0%不使用的时候不绘制，当100%的时候停止绘制，不用一直绘制占用内存）

五、未修复的问题
由于背景叶子风扇等都是图片，所以无法为其他分辨率进行适配~~